package com.example.arbitre.models;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.UnknownHostException;

import android.os.AsyncTask;
import android.util.Log;

// Singleton
public class ClientSocket{
	
	private static ClientSocket cs;
	private String serverIP = "151.80.159.27";
	private int serverPort = 6789;
	private Socket socket;
	private Thread thread;
	
	private ClientSocket()
	{
		//thread = new Thread(new ClientThread());
		//thread.start();
	}
	
	public static ClientSocket GetInstance(){
		if(cs == null)
			cs = new ClientSocket();
		
		return cs;
	}	
	
	/**
	 * Ecriture sur le serveur
	 * @param message le message a ecrire
	 * la commande a passer
	 */
	public void Write(String message){
		PrintStream out = null;
		try {
			out = new PrintStream(socket.getOutputStream(), true);
			out.write(message.getBytes());
		} catch (IOException e) {
			e.printStackTrace();
		}
		finally{
			//out.close();
		}
	}
	
	/**
	 * Lecture depuis le server
	 * @return le string lu.
	 */
	public String Read(){
		String res = "";
		InputStreamReader is = null;
		BufferedReader in = null;
		try {
			is = new InputStreamReader(socket.getInputStream());
			
			in = new BufferedReader(is);
	        
			res = in.readLine();
		} catch (IOException e) {
			e.printStackTrace();
		}
		finally{
			/*try {
				is.close();
				in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}*/
			
		}
		return res;
	}
	
	/**
	 * Fermeture du socket
	 */
	public void Close(){
		try {
			socket.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	// ACCESSORS

	public String getServerIP() {
		return serverIP;
	}

	public void setServerIP(String serverIP) {
		this.serverIP = serverIP;
	}

	public int getServerPort() {
		return serverPort;
	}

	public void setServerPort(int serverPort) {
		this.serverPort = serverPort;
	}

	/*class ClientThread implements Runnable {
	
		@Override
		public void run() {
			try {
				InetAddress serverAddr = InetAddress.getByName(serverIP);
				socket = new Socket(serverAddr, serverPort);
			} catch (UnknownHostException e1) {
				e1.printStackTrace();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
	}*/
}

public class NetworkTask extends AsyncTask<Void, byte[], Boolean> {
        Socket nsocket; //Network Socket
        InputStream nis; //Network Input Stream
        OutputStream nos; //Network Output Stream

        private String serverIP = "151.80.159.27";
    	private int serverPort = 6789;
        
        @Override
        protected void onPreExecute() {
            Log.i("AsyncTask", "onPreExecute");
        }

        @Override
        protected Boolean doInBackground(Void... params) { //This runs on a different thread
            boolean result = false;
            try {
                Log.i("AsyncTask", "doInBackground: Creating socket");
                SocketAddress sockaddr = new InetSocketAddress(serverIP, serverPort);
                nsocket = new Socket();
                nsocket.connect(sockaddr, 5000); //10 second connection timeout
                if (nsocket.isConnected()) { 
                    nis = nsocket.getInputStream();
                    nos = nsocket.getOutputStream();
                    Log.i("AsyncTask", "doInBackground: Socket created, streams assigned");
                    Log.i("AsyncTask", "doInBackground: Waiting for inital data...");
                    byte[] buffer = new byte[4096];
                    int read = nis.read(buffer, 0, 4096); //This is blocking
                    while(read != -1){
                        byte[] tempdata = new byte[read];
                        System.arraycopy(buffer, 0, tempdata, 0, read);
                        publishProgress(tempdata);
                        Log.i("AsyncTask", "doInBackground: Got some data");
                        read = nis.read(buffer, 0, 4096); //This is blocking
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
                Log.i("AsyncTask", "doInBackground: IOException");
                result = true;
            } catch (Exception e) {
                e.printStackTrace();
                Log.i("AsyncTask", "doInBackground: Exception");
                result = true;
            } finally {
                try {
                    nis.close();
                    nos.close();
                    nsocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                Log.i("AsyncTask", "doInBackground: Finished");
            }
            return result;
        }

        public void SendDataToNetwork(String cmd) { //You run this from the main thread.
            try {
                if (nsocket.isConnected()) {
                    Log.i("AsyncTask", "SendDataToNetwork: Writing received message to socket");
                    nos.write(cmd.getBytes());
                } else {
                    Log.i("AsyncTask", "SendDataToNetwork: Cannot send message. Socket is closed");
                }
            } catch (Exception e) {
                Log.i("AsyncTask", "SendDataToNetwork: Message send failed. Caught an exception");
            }
        }

        @Override
        protected void onProgressUpdate(byte[]... values) {
            if (values.length > 0) {
                Log.i("AsyncTask", "onProgressUpdate: " + values[0].length + " bytes received.");
            }
        }
        @Override
        protected void onCancelled() {
            Log.i("AsyncTask", "Cancelled.");
        }
        @Override
        protected void onPostExecute(Boolean result) {
            if (result) {
                Log.i("AsyncTask", "onPostExecute: Completed with an Error.");
            } else {
                Log.i("AsyncTask", "onPostExecute: Completed.");
            }
        }
    }
      
